
==================== FINAL INTERFACE ====================
2017-11-08 12:35:39.008412 UTC

interface main@main:Main 8002
  interface hash: 746d48222cc75e03e30e2304794ee4c3
  ABI hash: 78938d17118369203f388a4e41db96f0
  export-list hash: 5985b92186c66e5a334bd011b3f799b9
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: a028ba2eda76c11b6ff1fb6860301461
  sig of: Nothing
  used TH splices: False
  where
exports:
  Main.change
  Main.discretize
  Main.display
  Main.displayLength
  Main.magic
  Main.main
  Main.mapT
  Main.sample
  Main.scale
  Main.sinS
  Main.timeS
  Main.toBars
  Main.Signal{Main.Signal at}
  Main.Time
module dependencies:
package dependencies: base-4.9.1.0* ghc-prim-0.5.0.0
                      integer-gmp-1.0.0.1
orphans: base-4.9.1.0:GHC.Base base-4.9.1.0:GHC.Float
family instance modules: base-4.9.1.0:Control.Applicative
                         base-4.9.1.0:Data.Either base-4.9.1.0:Data.Functor.Const
                         base-4.9.1.0:Data.Monoid base-4.9.1.0:Data.Type.Equality
                         base-4.9.1.0:GHC.Generics base-4.9.1.0:GHC.IO.Exception
                         base-4.9.1.0:GHC.TypeLits
import  -/  base-4.9.1.0:Control.Monad a6784c5dab0d75c63dabec5a37843f98
import  -/  base-4.9.1.0:Data.Foldable 3e0b6967a1da89945d0e2d47266337a2
import  -/  base-4.9.1.0:GHC.Base c4231c43c07e46080a26bf94094c7aa1
import  -/  base-4.9.1.0:GHC.Float 33e2b9ffe427edd6a5c2fd6a3b26703c
import  -/  base-4.9.1.0:GHC.List ab8c4e523e6c479c549d3bcd5fc4a439
import  -/  base-4.9.1.0:GHC.Num 00bfaa7b2f9d6084913c0697a8a49ec8
import  -/  base-4.9.1.0:GHC.Real 82e4e59051a13dba1da63e1e970a69e6
import  -/  base-4.9.1.0:Prelude 22dd289b8469a8fa8dc81cab7b237771
import  -/  base-4.9.1.0:System.IO e4a64a8e3dce8616da54f0ee7104f7db
import  -/  ghc-prim-0.5.0.0:GHC.Types 89f8de4f08018c9177c98d979eae0e45
33f03c25dcae48eda9fe3467825751e4
  $fApplicativeSignal :: GHC.Base.Applicative Main.Signal
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Main.Signal
                  Main.$fFunctorSignal
                  Main.$fApplicativeSignal_$cpure
                  Main.$fApplicativeSignal_$c<*>
                  Main.$fApplicativeSignal_$c*>
                  Main.$fApplicativeSignal_$s$dm<* -}
33f03c25dcae48eda9fe3467825751e4
  $fApplicativeSignal1 ::
    (a -> b -> c) -> Main.Signal a -> Main.Signal b -> Main.Time -> c
  {- Arity: 4, HasNoCafRefs,
     Strictness: <C(C(S)),1*C1(C1(U))><L,1*C1(U)><L,1*C1(U)><L,U>,
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   @ b
                   @ c
                   (eta :: a -> b -> c)
                   (eta1 :: Main.Signal a)
                   (eta2 :: Main.Signal b)
                   (eta4 :: Main.Time) ->
                 eta
                   (eta1 `cast` (Main.N:Signal[0] <a>_N) eta4)
                   (eta2 `cast` (Main.N:Signal[0] <b>_N) eta4)) -}
33f03c25dcae48eda9fe3467825751e4
  $fApplicativeSignal2 ::
    Main.Signal a -> Main.Signal b -> Main.Time -> b
  {- Arity: 3, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)><L,U>,
     Unfolding: InlineRule (3, True, True)
                (\ @ a
                   @ b
                   (eta :: Main.Signal a)
                   (eta1 :: Main.Signal b)
                   (eta2 :: Main.Time) ->
                 eta1 `cast` (Main.N:Signal[0] <b>_N) eta2) -}
33f03c25dcae48eda9fe3467825751e4
  $fApplicativeSignal3 ::
    Main.Signal (a -> b) -> Main.Signal a -> Main.Time -> b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <C(C(S)),1*C1(C1(U))><L,1*C1(U)><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ b
                   (fs :: Main.Signal (a -> b))
                   (xs :: Main.Signal a)
                   (t :: Main.Time) ->
                 fs `cast` (Main.N:Signal[0] <a -> b>_N)
                   t
                   (xs `cast` (Main.N:Signal[0] <a>_N) t)) -}
8791c1ceb7a103cfa03b6a8d4eade3d4
  $fApplicativeSignal4 :: a -> Main.Time -> a
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,A>,
     Unfolding: InlineRule (2, True, True)
                (\ @ a (x :: a) (ds1 :: Main.Time) -> x) -}
33f03c25dcae48eda9fe3467825751e4
  $fApplicativeSignal_$c*> ::
    Main.Signal a -> Main.Signal b -> Main.Signal b
  {- Arity: 3, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)><L,U>,
     Unfolding: InlineRule (0, True, True)
                Main.$fApplicativeSignal2
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N).
                 <Main.Signal a>_R
                 ->_R <Main.Signal b>_R
                 ->_R Sym (Main.N:Signal[0]) <b>_N) -}
33f03c25dcae48eda9fe3467825751e4
  $fApplicativeSignal_$c<*> ::
    Main.Signal (a -> b) -> Main.Signal a -> Main.Signal b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <C(C(S)),1*C1(C1(U))><L,1*C1(U)><L,U>,
     Unfolding: InlineRule (0, True, True)
                Main.$fApplicativeSignal3
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N).
                 <Main.Signal (a -> b)>_R
                 ->_R <Main.Signal a>_R
                 ->_R Sym (Main.N:Signal[0]) <b>_N) -}
33f03c25dcae48eda9fe3467825751e4
  $fApplicativeSignal_$cpure :: a -> Main.Signal a
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,A>,
     Unfolding: InlineRule (0, True, True)
                Main.$fApplicativeSignal4
                  `cast`
                (forall (a :: <*>_N). <a>_R ->_R Sym (Main.N:Signal[0]) <a>_N) -}
33f03c25dcae48eda9fe3467825751e4
  $fApplicativeSignal_$s$dm<* ::
    Main.Signal a -> Main.Signal b -> Main.Signal a
  {- Arity: 3, HasNoCafRefs, Strictness: <C(S),1*C1(U)><L,A><L,U>,
     Unfolding: InlineRule (-1, True, False)
                (\ @ a
                   @ b
                   (eta :: Main.Signal a)
                   (eta1 :: Main.Signal b)
                   (eta2 :: Main.Time) ->
                 (Main.$fApplicativeSignal_$sliftA2
                    @ a
                    @ b
                    @ a
                    (GHC.Base.const @ a @ b)
                    eta
                    eta1)
                   `cast`
                 (Main.N:Signal[0] <a>_N)
                   eta2)
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N).
                 <Main.Signal a>_R
                 ->_R <Main.Signal b>_R
                 ->_R Sym (Main.N:Signal[0]) <a>_N) -}
33f03c25dcae48eda9fe3467825751e4
  $fApplicativeSignal_$sliftA2 ::
    (a -> b -> c) -> Main.Signal a -> Main.Signal b -> Main.Signal c
  {- Arity: 4, HasNoCafRefs,
     Strictness: <C(C(S)),1*C1(C1(U))><L,1*C1(U)><L,1*C1(U)><L,U>,
     Unfolding: InlineRule (0, True, True)
                Main.$fApplicativeSignal1
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N) (c :: <*>_N).
                 <a -> b -> c>_R
                 ->_R <Main.Signal a>_R
                 ->_R <Main.Signal b>_R
                 ->_R Sym (Main.N:Signal[0]) <c>_N) -}
33f03c25dcae48eda9fe3467825751e4
  $fFunctorSignal :: GHC.Base.Functor Main.Signal
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Main.Signal
                  Main.$fFunctorSignal_$cfmap
                  Main.$fFunctorSignal_$c<$ -}
33f03c25dcae48eda9fe3467825751e4
  $fFunctorSignal1 :: a -> Main.Signal b -> Main.Time -> a
  {- Arity: 3, HasNoCafRefs, Strictness: <S,1*U><L,A><L,A>,
     Unfolding: InlineRule (3, True, True)
                (\ @ b @ a (eta :: a) (xs :: Main.Signal b) (eta1 :: Main.Time) ->
                 eta) -}
33f03c25dcae48eda9fe3467825751e4
  $fFunctorSignal2 :: (a -> b) -> Main.Signal a -> Main.Time -> b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <C(S),1*C1(U)><L,1*C1(U)><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ b
                   (f :: a -> b)
                   (xs :: Main.Signal a)
                   (eta :: Main.Time) ->
                 f (xs `cast` (Main.N:Signal[0] <a>_N) eta)) -}
33f03c25dcae48eda9fe3467825751e4
  $fFunctorSignal_$c<$ :: a -> Main.Signal b -> Main.Signal a
  {- Arity: 3, HasNoCafRefs, Strictness: <S,1*U><L,A><L,A>,
     Unfolding: InlineRule (0, True, True)
                (\ @ a @ b -> Main.$fFunctorSignal1 @ b @ a)
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N).
                 <a>_R ->_R <Main.Signal b>_R ->_R Sym (Main.N:Signal[0]) <a>_N) -}
33f03c25dcae48eda9fe3467825751e4
  $fFunctorSignal_$cfmap ::
    (a -> b) -> Main.Signal a -> Main.Signal b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <C(S),1*C1(U)><L,1*C1(U)><L,U>,
     Unfolding: InlineRule (0, True, True)
                Main.$fFunctorSignal2
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N).
                 <a -> b>_R
                 ->_R <Main.Signal a>_R
                 ->_R Sym (Main.N:Signal[0]) <b>_N) -}
e5d9bf71dc189bda745adc43f17031a2
  $seven1 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (0) -}
d2a4c813679633b0caf12fcccf00e734
  $seven2 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (2) -}
ad8599ee42a7bbdbe0d40efc1d03b648
  $tc'Signal :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1902553774120075534##
                   9103033085656458897##
                   Main.$trModule
                   Main.$tc'Signal1) -}
bd3ef5d2adee6ed48ccea14292e8ecd3
  $tc'Signal1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Signal"#) -}
88455af423137cfdaaac1007d9cf636c
  $tcSignal :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17878828734518317431##
                   5918583374272989356##
                   Main.$trModule
                   Main.$tcSignal1) -}
ef98c6eb44af4128bd8baf7d063fe544
  $tcSignal1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Signal"#) -}
d6831ef04cb9301b090dfae6f7bb7ec7
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module Main.$trModule2 Main.$trModule1) -}
847d9fc3b8e6f0b424199f36b4999bb2
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Main"#) -}
24ef6042833e75ffd7aa98b83ecca98d
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "main"#) -}
804ebf81b9e536272f87887276ec2877
  $wtoBars :: GHC.Prim.Int# -> [GHC.Types.Char]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#) ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<# 0# ww) of wild {
                   GHC.Types.False -> GHC.Types.[] @ GHC.Types.Char
                   GHC.Types.True -> Main.$wxs ww }) -}
c36eae3df64010dd3f9ed36017735af2
  $wxs :: GHC.Prim.Int# -> [GHC.Types.Char]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>, Inline: [0] -}
33f03c25dcae48eda9fe3467825751e4
  newtype Signal a = Signal {at :: Main.Time -> a}
cf2f3efeb7e56588cff9b4ab743eef1c
  type Time = GHC.Types.Double
1a439530f2e9c35ea6037dd3548858a3
  at :: Main.Signal a -> Main.Time -> a
  RecSel Left Main.Signal
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Main.at1
                  `cast`
                (forall (a :: <*>_N).
                 <Main.Signal a>_R ->_R Main.N:Signal[0] <a>_N) -}
b426f109bbbbbd2f08c8741bc8b7f67c
  at1 :: Main.Signal a -> Main.Signal a
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, True)
                (\ @ a (ds1 :: Main.Signal a) -> ds1) -}
937aab0cf40c6b5b4ed8c9e7bfbcd4aa
  change :: GHC.Real.RealFrac a => t -> t -> a -> t
  {- Arity: 4,
     Strictness: <S(LLLLLLC(C(S))),1*U(A,A,A,A,A,A,1*C1(C1(U)))><L,1*U><L,1*U><L,U>,
     Unfolding: (\ @ a
                   @ t
                   ($dRealFrac :: GHC.Real.RealFrac a)
                   (a1 :: t)
                   (b :: t)
                   (t1 :: a) ->
                 case GHC.Integer.Type.eqInteger#
                        (GHC.Integer.Type.remInteger
                           (GHC.Real.floor
                              @ a
                              $dRealFrac
                              @ GHC.Integer.Type.Integer
                              GHC.Real.$fIntegralInteger
                              t1)
                           Main.$seven2)
                        Main.$seven1 of wild { DEFAULT ->
                 case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild of wild1 {
                   GHC.Types.False -> a1 GHC.Types.True -> b } }) -}
65e0b316d88dab3b7ee3bd5899fea8ab
  discretize ::
    Main.Signal GHC.Types.Double -> Main.Signal GHC.Types.Int
  {- Arity: 2, HasNoCafRefs, Strictness: <C(S(S)),1*C1(U(U))><L,U>m,
     Unfolding: InlineRule (0, True, True)
                Main.discretize1
                  `cast`
                (<Main.Signal GHC.Types.Double>_R
                 ->_R Sym (Main.N:Signal[0]) <GHC.Types.Int>_N) -}
deeed549dc53ec13f0c85e3e810b5e58
  discretize1 ::
    Main.Signal GHC.Types.Double -> Main.Time -> GHC.Types.Int
  {- Arity: 2, HasNoCafRefs, Strictness: <C(S(S)),1*C1(U(U))><L,U>m,
     Unfolding: InlineRule (2, True, False)
                (\ (xs :: Main.Signal GHC.Types.Double) (eta :: Main.Time) ->
                 case xs `cast` (Main.N:Signal[0] <GHC.Types.Double>_N)
                        eta of ds1 { GHC.Types.D# ds2 ->
                 case {__pkg_ccall base-4.9.1.0 rintDouble GHC.Prim.Double#
                                                           -> GHC.Prim.State# GHC.Prim.RealWorld
                                                           -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                                 GHC.Prim.Double# #)}
                        ds2
                        GHC.Prim.realWorld# of wild { (#,#) ds3 ds4 ->
                 GHC.Types.I# (GHC.Prim.double2Int# ds4) } }) -}
716e48b44527921dd9978c0bb8ae37d9
  display :: Main.Signal GHC.Base.String -> GHC.Types.IO ()
  {- Arity: 2, Strictness: <L,C(U)><S,U>,
     Unfolding: InlineRule (0, True, True)
                Main.display1
                  `cast`
                (<Main.Signal GHC.Base.String>_R
                 ->_R Sym (GHC.Types.N:IO[0] <()>_R)) -}
e0bf2805f2adac0cc77f11428bf29e6e
  display1 ::
    Main.Signal GHC.Base.String
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 2, Strictness: <L,C(U)><S,U>,
     Unfolding: (\ (ss :: Main.Signal GHC.Base.String)
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 letrec {
                   go :: [Main.Time]
                         -> GHC.Prim.State# GHC.Prim.RealWorld
                         -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
                     {- Arity: 2, Strictness: <S,1*U><S,U> -}
                   = \ (ds1 :: [Main.Time])
                       (eta1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                     case ds1 of wild {
                       [] -> (# eta1, GHC.Tuple.() #)
                       : y ys
                       -> case GHC.IO.Handle.Text.hPutStr2
                                 GHC.IO.Handle.FD.stdout
                                 (ss `cast` (Main.N:Signal[0] <GHC.Base.String>_N) y)
                                 GHC.Types.True
                                 eta1 of ds2 { (#,#) ipv ipv1 ->
                          go ys ipv } }
                 } in
                 go Main.display2 eta) -}
cb49dbe9f9cce2938f35c94c11cd7853
  display2 :: [GHC.Types.Double]
  {- Unfolding: (GHC.Real.numericEnumFromTo
                   @ GHC.Types.Double
                   GHC.Classes.$fOrdDouble
                   GHC.Float.$fFractionalDouble
                   Main.display3
                   Main.displayLength) -}
94d73921723ddb449c9eae3dab74ff1d
  display3 :: GHC.Types.Double
  {- HasNoCafRefs, Unfolding: (GHC.Types.D# 0.0##) -}
f127d07114c7aaa25a78025f289982d4
  displayLength :: Main.Time
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.D# 500.0##) -}
bf93f4b9b3558335e768807d6d80c9cb
  magic :: Main.Signal GHC.Types.Double -> GHC.Types.IO ()
  {- Arity: 2, Strictness: <L,C(U(U))><S,U>,
     Unfolding: InlineRule (0, True, True)
                Main.magic1
                  `cast`
                (<Main.Signal GHC.Types.Double>_R
                 ->_R Sym (GHC.Types.N:IO[0] <()>_R)) -}
d392acf13bbf81a955f1b7377278b761
  magic1 ::
    Main.Signal GHC.Types.Double
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 2, Strictness: <L,C(U(U))><S,U>,
     Unfolding: (\ (x :: Main.Signal GHC.Types.Double)
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 letrec {
                   go :: [Main.Time]
                         -> GHC.Prim.State# GHC.Prim.RealWorld
                         -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
                     {- Arity: 2, Strictness: <S,1*U><S,U> -}
                   = \ (ds1 :: [Main.Time])
                       (eta1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                     case ds1 of wild {
                       [] -> (# eta1, GHC.Tuple.() #)
                       : y ys
                       -> case GHC.IO.Handle.Text.hPutStr2
                                 GHC.IO.Handle.FD.stdout
                                 (case x `cast` (Main.N:Signal[0] <GHC.Types.Double>_N)
                                         y of wild1 { GHC.Types.D# y1 ->
                                  case {__pkg_ccall base-4.9.1.0 rintDouble GHC.Prim.Double#
                                                                            -> GHC.Prim.State#
                                                                                 GHC.Prim.RealWorld
                                                                            -> (# GHC.Prim.State#
                                                                                    GHC.Prim.RealWorld,
                                                                                  GHC.Prim.Double# #)}
                                         (GHC.Prim.*## 30.0## (GHC.Prim.+## 1.0## y1))
                                         GHC.Prim.realWorld# of wild2 { (#,#) ds2 ds3 ->
                                  let {
                                    ww :: GHC.Prim.Int# = GHC.Prim.double2Int# ds3
                                  } in
                                  case GHC.Prim.tagToEnum#
                                         @ GHC.Types.Bool
                                         (GHC.Prim.<# 0# ww) of wild3 {
                                    GHC.Types.False -> GHC.Types.[] @ GHC.Types.Char
                                    GHC.Types.True -> Main.$wxs ww } } })
                                 GHC.Types.True
                                 eta1 of ds2 { (#,#) ipv ipv1 ->
                          go ys ipv } }
                 } in
                 go Main.display2 eta) -}
01e16ff76a165d2728af3423bc3ef628
  main :: GHC.Types.IO ()
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                Main.main1 `cast` (Sym (GHC.Types.N:IO[0] <()>_R)) -}
410d5ba32c15d9d08300b16c87667a57
  main1 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 1,
     Unfolding: (Main.magic1
                   Main.main2 `cast` (Sym (Main.N:Signal[0]) <Main.Time>_N)) -}
491182e073b8c52a297a606ac0a08505
  main2 :: Main.Time -> Main.Time
  {- Arity: 1, HasNoCafRefs, Strictness: <S(S),1*U(U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (t :: Main.Time) ->
                 case t of wild1 { GHC.Types.D# y ->
                 GHC.Types.D# (GHC.Prim.sinDouble# (GHC.Prim.*## 0.1## y)) }) -}
90701c30324ed2e79142ca4ac1f09b49
  main3 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 1,
     Unfolding: (GHC.TopHandler.runMainIO1
                   @ ()
                   Main.main1 `cast` (Sym (GHC.Types.N:IO[0] <()>_R))) -}
e461696a63ade3788e57d9c68f375699
  mapT :: (Main.Time -> Main.Time) -> Main.Signal a -> Main.Signal a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*C1(U)><C(S),1*C1(U)><L,U>,
     Unfolding: InlineRule (0, True, True)
                Main.mapT1
                  `cast`
                (forall (a :: <*>_N).
                 <Main.Time -> Main.Time>_R
                 ->_R <Main.Signal a>_R
                 ->_R Sym (Main.N:Signal[0]) <a>_N) -}
80ffaba41a3869152d07a3c5a90e5229
  mapT1 ::
    (Main.Time -> Main.Time) -> Main.Signal a -> Main.Time -> a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*C1(U)><C(S),1*C1(U)><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   (f :: Main.Time -> Main.Time)
                   (xs :: Main.Signal a)
                   (t :: Main.Time) ->
                 xs `cast` (Main.N:Signal[0] <a>_N) (f t)) -}
91dd521a7d8423e7c869ce7b90a32b81
  sample :: Main.Signal a -> Main.Time -> a
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Main.at1
                  `cast`
                (forall (a :: <*>_N).
                 <Main.Signal a>_R ->_R Main.N:Signal[0] <a>_N) -}
e104ad97df9e6c42357565a2bf56084e
  scale :: GHC.Num.Num a => Main.Signal a -> Main.Signal a
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(1*C1(U),A,1*C1(U),A,A,A,C(U))>,
     Unfolding: (\ @ a ($dNum :: GHC.Num.Num a) ->
                 let {
                   f :: a -> a
                   = GHC.Num.* @ a $dNum (GHC.Num.fromInteger @ a $dNum Main.scale3)
                 } in
                 let {
                   g :: a -> a
                   = GHC.Num.+ @ a $dNum (GHC.Num.fromInteger @ a $dNum Main.scale2)
                 } in
                 (\ (xs :: Main.Signal a) (eta :: Main.Time) ->
                  f (g (xs `cast` (Main.N:Signal[0] <a>_N) eta)))
                   `cast`
                 (<Main.Signal a>_R ->_R Sym (Main.N:Signal[0]) <a>_N)) -}
b5f6037376de0b28e49f508e07c47a81
  scale2 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (1) -}
a6b915122e975c647222ab51ea2c35f0
  scale3 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (30) -}
f93bacb990fcca717ebd8d8f92c9ee1d
  sinS :: GHC.Types.Double -> Main.Signal GHC.Types.Double
  {- Arity: 2, HasNoCafRefs, Strictness: <S(S),1*U(U)><S(S),1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                Main.sinS1
                  `cast`
                (<GHC.Types.Double>_R ->_R Sym (Main.N:Signal[0]) <Main.Time>_N) -}
c248687aae979a0a8d3e7df516237eca
  sinS1 :: GHC.Types.Double -> Main.Time -> Main.Time
  {- Arity: 2, HasNoCafRefs, Strictness: <S(S),1*U(U)><S(S),1*U(U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (freq :: GHC.Types.Double) (t :: Main.Time) ->
                 case freq of wild { GHC.Types.D# x ->
                 case t of wild1 { GHC.Types.D# y ->
                 GHC.Types.D# (GHC.Prim.sinDouble# (GHC.Prim.*## x y)) } }) -}
746be8f4aa4cafb2d61fa302fdc204d7
  timeS :: Main.Signal Main.Time
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (0, True, True)
                (GHC.Base.id @ Main.Time)
                  `cast`
                (Sym (Main.N:Signal[0]) <Main.Time>_N) -}
8ddd162c99290fb6682bc8cf81577538
  toBars :: Main.Signal GHC.Types.Int -> Main.Signal GHC.Base.String
  {- Arity: 2, HasNoCafRefs, Strictness: <C(S(S)),1*C1(U(U))><L,U>,
     Unfolding: InlineRule (0, True, True)
                Main.toBars1
                  `cast`
                (<Main.Signal GHC.Types.Int>_R
                 ->_R Sym (Main.N:Signal[0]) <[GHC.Types.Char]>_N) -}
b79365a935203974ad94fb224a67e88b
  toBars1 ::
    Main.Signal GHC.Types.Int -> Main.Time -> [GHC.Types.Char]
  {- Arity: 2, HasNoCafRefs, Strictness: <C(S(S)),1*C1(U(U))><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (xs :: Main.Signal GHC.Types.Int) (eta :: Main.Time) ->
                 Main.toBars2
                   (xs `cast` (Main.N:Signal[0] <GHC.Types.Int>_N) eta)) -}
0bf3c8fa9a1764523bcd74e437becf6a
  toBars2 :: GHC.Types.Int -> [GHC.Types.Char]
  {- Arity: 1, HasNoCafRefs, Strictness: <S(S),1*U(U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: GHC.Types.Int) ->
                 case w of ww { GHC.Types.I# ww1 -> Main.$wtoBars ww1 }) -}
instance [safe] GHC.Base.Applicative [Main.Signal]
  = Main.$fApplicativeSignal
instance [safe] GHC.Base.Functor [Main.Signal]
  = Main.$fFunctorSignal
"SPEC/Main $dm<* @ Signal" [ALWAYS] forall ($dApplicative :: GHC.Base.Applicative
                                                               Main.Signal)
  GHC.Base.$dm<* @ Main.Signal $dApplicative
  = Main.$fApplicativeSignal_$s$dm<*
"SPEC/Main liftA2 @ Signal _ _ _" [ALWAYS] forall @ a
                                                  @ b
                                                  @ c
                                                  ($dApplicative :: GHC.Base.Applicative
                                                                      Main.Signal)
  GHC.Base.liftA2 @ Main.Signal @ a @ b @ c $dApplicative
  = Main.$fApplicativeSignal_$sliftA2 @ a @ b @ c
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

